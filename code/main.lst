CCS PCM C Compiler, Version 4.074, 38112               15-mai-15 01:46

               Filename: C:\Users\User\Desktop\Nova pasta\main.lst

               ROM used: 1599 words (39%)
                         Largest free fragment is 2048
               RAM used: 54 (28%) at main() level
                         68 (36%) worst case
               Stack:    5 worst case (4 in main + 1 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   4DF
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  26
0008:  MOVF   7F,W
0009:  MOVWF  25
000A:  MOVF   0A,W
000B:  MOVWF  2D
000C:  CLRF   0A
000D:  SWAPF  25,F
000E:  MOVF   04,W
000F:  MOVWF  27
0010:  MOVF   20,W
0011:  MOVWF  28
0012:  MOVF   21,W
0013:  MOVWF  29
0014:  MOVF   22,W
0015:  MOVWF  2A
0016:  MOVF   23,W
0017:  MOVWF  2B
0018:  MOVF   24,W
0019:  MOVWF  2C
001A:  BCF    03.7
001B:  BCF    03.5
001C:  BTFSS  0B.4
001D:  GOTO   020
001E:  BTFSC  0B.1
001F:  GOTO   033
0020:  MOVF   27,W
0021:  MOVWF  04
0022:  MOVF   28,W
0023:  MOVWF  20
0024:  MOVF   29,W
0025:  MOVWF  21
0026:  MOVF   2A,W
0027:  MOVWF  22
0028:  MOVF   2B,W
0029:  MOVWF  23
002A:  MOVF   2C,W
002B:  MOVWF  24
002C:  MOVF   2D,W
002D:  MOVWF  0A
002E:  SWAPF  26,W
002F:  MOVWF  03
0030:  SWAPF  7F,F
0031:  SWAPF  7F,W
0032:  RETFIE
0033:  BCF    0A.3
0034:  GOTO   03D
.................... #include <16F873A.h>            //PIC 8bits 
.................... //////// Standard Header file for the PIC16F873A device //////////////// 
.................... #device PIC16F873A 
.................... #list 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES XT                       //Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #use delay(clock=4000000)       //Clock de 4MHZ externo 
*
00B1:  MOVLW  57
00B2:  MOVWF  04
00B3:  MOVF   00,W
00B4:  BTFSC  03.2
00B5:  GOTO   0C4
00B6:  MOVLW  01
00B7:  MOVWF  21
00B8:  CLRF   20
00B9:  DECFSZ 20,F
00BA:  GOTO   0B9
00BB:  DECFSZ 21,F
00BC:  GOTO   0B8
00BD:  MOVLW  4A
00BE:  MOVWF  20
00BF:  DECFSZ 20,F
00C0:  GOTO   0BF
00C1:  GOTO   0C2
00C2:  DECFSZ 00,F
00C3:  GOTO   0B6
00C4:  RETLW  00
....................  
.................... #include <NRF24L01P.c> 
.................... //----------------------------------------------------------------------------// 
.................... // NRF24L01P.C                                                                // 
.................... // Ezequiel Donhauser                                                         // 
.................... //                                                                            // 
.................... // esse arquivo contem as configuraçoes do modulo NORDIC NRF24L01+            // 
.................... // funçoes: recebe_dados(); | envia_dados(); | config_nrf24()                 // 
.................... // Configuraçoes: CANAL(1-126) | BUFFER(1-32) | ENDTX(1-255) | ENDRX(1-255)   // 
.................... //                                                                            // 
.................... // OBS: os canais devem ser o mesmo nos modulos que se comunicarão, o buffer  // 
.................... // tambem deve ser o mesmo validos de 1a32 Bytes, ENDTX e ENDRX tambem devem  // 
.................... // ser os mesmos(endereço), a potencia de transmissão foi configurada para    // 
.................... // 0dbm(maxima), taxa de transferencia em 250Kbps, autoACK ativado, e nenhuma // 
.................... // retransmissão de pacotes, para outras configuraçoes consulte o datasheet.  // 
.................... //----------------------------------------------------------------------------// 
....................  
.................... //configure aqui os parametros desejados 
.................... #define CANAL    107 // 1 a 126 
.................... #define BUFFER   10  // 1 a 32 
.................... #define ENDTX    75  // 1 a 255 
.................... #define ENDRX    75  // 1 a 255 
....................  
.................... //configuraçoes dos PINOS 
.................... #define     IRQ         PIN_B0     //PIC(RB0)  <->  MODULO(IRQ) 
.................... #define     CSN         PIN_C1     //PIC(RC1)  <->  MODULO(CSN) 
.................... #define     CE          PIN_C2     //PIC(RC2)  <->  MODULO(CE) 
.................... #define     IRQ_TR      TRISB,0 
.................... #define     CSN_TR      TRISC,1 
.................... #define     CE_TR       TRISC,2 
.................... #BYTE       TRISA       =0x85 
.................... #BYTE       TRISB       =0x86 
.................... #BYTE       TRISC       =0x87 
.................... #BYTE       INTCON      =0x00B 
....................  
.................... //variaveis globais 
.................... static int16       espera_ack; 
*
04E9:  BCF    03.5
04EA:  CLRF   2E
04EB:  CLRF   2F
.................... static int1        ACK; 
04EC:  BCF    30.0
.................... static int8        RECEBE[BUFFER]; 
04ED:  CLRF   31
04EE:  CLRF   32
04EF:  CLRF   33
04F0:  CLRF   34
04F1:  CLRF   35
04F2:  CLRF   36
04F3:  CLRF   37
04F4:  CLRF   38
04F5:  CLRF   39
04F6:  CLRF   3A
.................... static int8        ENVIA [BUFFER]; 
04F7:  CLRF   3B
04F8:  CLRF   3C
04F9:  CLRF   3D
04FA:  CLRF   3E
04FB:  CLRF   3F
04FC:  CLRF   40
04FD:  CLRF   41
04FE:  CLRF   42
04FF:  CLRF   43
0500:  CLRF   44
....................  
.................... //função que configura modulo 
.................... void config_nrf24(){ 
....................  
....................    bit_clear(CSN_TR); 
*
017F:  BSF    03.5
0180:  BCF    07.1
....................    bit_set(IRQ_TR); 
0181:  BSF    06.0
....................    bit_clear(CE_TR); 
0182:  BCF    07.2
....................  
....................    //configura modulo SPI 
....................    setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_XMIT_L_TO_H 
....................    |SPI_CLK_DIV_4|SPI_SAMPLE_AT_END); 
0183:  BCF    03.5
0184:  BCF    14.5
0185:  BCF    45.5
0186:  MOVF   45,W
0187:  BSF    03.5
0188:  MOVWF  07
0189:  BCF    03.5
018A:  BSF    45.4
018B:  MOVF   45,W
018C:  BSF    03.5
018D:  MOVWF  07
018E:  BCF    03.5
018F:  BCF    45.3
0190:  MOVF   45,W
0191:  BSF    03.5
0192:  MOVWF  07
0193:  MOVLW  20
0194:  BCF    03.5
0195:  MOVWF  14
0196:  MOVLW  C0
0197:  BSF    03.5
0198:  MOVWF  14
....................     
....................    output_low(CE); 
0199:  BCF    03.5
019A:  BCF    45.2
019B:  MOVF   45,W
019C:  BSF    03.5
019D:  MOVWF  07
019E:  BCF    03.5
019F:  BCF    07.2
....................  
....................    //RX_ADDR_P0 - configura endereço de recepção PIPE0 
....................    output_low(CSN); 
01A0:  BCF    45.1
01A1:  MOVF   45,W
01A2:  BSF    03.5
01A3:  MOVWF  07
01A4:  BCF    03.5
01A5:  BCF    07.1
....................    spi_write(0x2A); 
01A6:  MOVF   13,W
01A7:  MOVLW  2A
01A8:  MOVWF  13
01A9:  BSF    03.5
01AA:  RRF    14,W
01AB:  BTFSS  03.0
01AC:  GOTO   1AA
....................    spi_write(ENDRX); 
01AD:  BCF    03.5
01AE:  MOVF   13,W
01AF:  MOVLW  4B
01B0:  MOVWF  13
01B1:  BSF    03.5
01B2:  RRF    14,W
01B3:  BTFSS  03.0
01B4:  GOTO   1B2
....................    spi_write(0xC2); 
01B5:  BCF    03.5
01B6:  MOVF   13,W
01B7:  MOVLW  C2
01B8:  MOVWF  13
01B9:  BSF    03.5
01BA:  RRF    14,W
01BB:  BTFSS  03.0
01BC:  GOTO   1BA
....................    spi_write(0xC2); 
01BD:  BCF    03.5
01BE:  MOVF   13,W
01BF:  MOVLW  C2
01C0:  MOVWF  13
01C1:  BSF    03.5
01C2:  RRF    14,W
01C3:  BTFSS  03.0
01C4:  GOTO   1C2
....................    spi_write(0xC2); 
01C5:  BCF    03.5
01C6:  MOVF   13,W
01C7:  MOVLW  C2
01C8:  MOVWF  13
01C9:  BSF    03.5
01CA:  RRF    14,W
01CB:  BTFSS  03.0
01CC:  GOTO   1CA
....................    spi_write(0xC2); 
01CD:  BCF    03.5
01CE:  MOVF   13,W
01CF:  MOVLW  C2
01D0:  MOVWF  13
01D1:  BSF    03.5
01D2:  RRF    14,W
01D3:  BTFSS  03.0
01D4:  GOTO   1D2
....................    output_high(CSN); 
01D5:  BCF    03.5
01D6:  BCF    45.1
01D7:  MOVF   45,W
01D8:  BSF    03.5
01D9:  MOVWF  07
01DA:  BCF    03.5
01DB:  BSF    07.1
....................     
....................    //TX_ADDR - configura endereço de transmissão 
....................    output_low(CSN); 
01DC:  BCF    45.1
01DD:  MOVF   45,W
01DE:  BSF    03.5
01DF:  MOVWF  07
01E0:  BCF    03.5
01E1:  BCF    07.1
....................    spi_write(0x30); 
01E2:  MOVF   13,W
01E3:  MOVLW  30
01E4:  MOVWF  13
01E5:  BSF    03.5
01E6:  RRF    14,W
01E7:  BTFSS  03.0
01E8:  GOTO   1E6
....................    spi_write(ENDTX); 
01E9:  BCF    03.5
01EA:  MOVF   13,W
01EB:  MOVLW  4B
01EC:  MOVWF  13
01ED:  BSF    03.5
01EE:  RRF    14,W
01EF:  BTFSS  03.0
01F0:  GOTO   1EE
....................    spi_write(0xC2); 
01F1:  BCF    03.5
01F2:  MOVF   13,W
01F3:  MOVLW  C2
01F4:  MOVWF  13
01F5:  BSF    03.5
01F6:  RRF    14,W
01F7:  BTFSS  03.0
01F8:  GOTO   1F6
....................    spi_write(0xC2); 
01F9:  BCF    03.5
01FA:  MOVF   13,W
01FB:  MOVLW  C2
01FC:  MOVWF  13
01FD:  BSF    03.5
01FE:  RRF    14,W
01FF:  BTFSS  03.0
0200:  GOTO   1FE
....................    spi_write(0xC2); 
0201:  BCF    03.5
0202:  MOVF   13,W
0203:  MOVLW  C2
0204:  MOVWF  13
0205:  BSF    03.5
0206:  RRF    14,W
0207:  BTFSS  03.0
0208:  GOTO   206
....................    spi_write(0xC2); 
0209:  BCF    03.5
020A:  MOVF   13,W
020B:  MOVLW  C2
020C:  MOVWF  13
020D:  BSF    03.5
020E:  RRF    14,W
020F:  BTFSS  03.0
0210:  GOTO   20E
....................    output_high(CSN); 
0211:  BCF    03.5
0212:  BCF    45.1
0213:  MOVF   45,W
0214:  BSF    03.5
0215:  MOVWF  07
0216:  BCF    03.5
0217:  BSF    07.1
....................  
....................    //EN_AA - habilita autoACK no PIPE0 
....................    output_low(CSN); 
0218:  BCF    45.1
0219:  MOVF   45,W
021A:  BSF    03.5
021B:  MOVWF  07
021C:  BCF    03.5
021D:  BCF    07.1
....................    spi_write(0x21); 
021E:  MOVF   13,W
021F:  MOVLW  21
0220:  MOVWF  13
0221:  BSF    03.5
0222:  RRF    14,W
0223:  BTFSS  03.0
0224:  GOTO   222
....................    spi_write(0x01); 
0225:  BCF    03.5
0226:  MOVF   13,W
0227:  MOVLW  01
0228:  MOVWF  13
0229:  BSF    03.5
022A:  RRF    14,W
022B:  BTFSS  03.0
022C:  GOTO   22A
....................    output_high(CSN); 
022D:  BCF    03.5
022E:  BCF    45.1
022F:  MOVF   45,W
0230:  BSF    03.5
0231:  MOVWF  07
0232:  BCF    03.5
0233:  BSF    07.1
....................  
....................    //EN_RXADDR - ativa o PIPE0 
....................    output_low(CSN); 
0234:  BCF    45.1
0235:  MOVF   45,W
0236:  BSF    03.5
0237:  MOVWF  07
0238:  BCF    03.5
0239:  BCF    07.1
....................    spi_write(0x22); 
023A:  MOVF   13,W
023B:  MOVLW  22
023C:  MOVWF  13
023D:  BSF    03.5
023E:  RRF    14,W
023F:  BTFSS  03.0
0240:  GOTO   23E
....................    spi_write(0x01); 
0241:  BCF    03.5
0242:  MOVF   13,W
0243:  MOVLW  01
0244:  MOVWF  13
0245:  BSF    03.5
0246:  RRF    14,W
0247:  BTFSS  03.0
0248:  GOTO   246
....................    output_high(CSN); 
0249:  BCF    03.5
024A:  BCF    45.1
024B:  MOVF   45,W
024C:  BSF    03.5
024D:  MOVWF  07
024E:  BCF    03.5
024F:  BSF    07.1
....................  
....................    //SETUP_AW - define o endereço com tamanho de 5 Bytes 
....................    output_low(CSN); 
0250:  BCF    45.1
0251:  MOVF   45,W
0252:  BSF    03.5
0253:  MOVWF  07
0254:  BCF    03.5
0255:  BCF    07.1
....................    spi_write(0x23); 
0256:  MOVF   13,W
0257:  MOVLW  23
0258:  MOVWF  13
0259:  BSF    03.5
025A:  RRF    14,W
025B:  BTFSS  03.0
025C:  GOTO   25A
....................    spi_write(0x03); 
025D:  BCF    03.5
025E:  MOVF   13,W
025F:  MOVLW  03
0260:  MOVWF  13
0261:  BSF    03.5
0262:  RRF    14,W
0263:  BTFSS  03.0
0264:  GOTO   262
....................    output_high(CSN); 
0265:  BCF    03.5
0266:  BCF    45.1
0267:  MOVF   45,W
0268:  BSF    03.5
0269:  MOVWF  07
026A:  BCF    03.5
026B:  BSF    07.1
....................  
....................    //SETUP_RETR - configura para nao retransmitir pacotes 
....................    output_low(CSN); 
026C:  BCF    45.1
026D:  MOVF   45,W
026E:  BSF    03.5
026F:  MOVWF  07
0270:  BCF    03.5
0271:  BCF    07.1
....................    spi_write(0x24); 
0272:  MOVF   13,W
0273:  MOVLW  24
0274:  MOVWF  13
0275:  BSF    03.5
0276:  RRF    14,W
0277:  BTFSS  03.0
0278:  GOTO   276
....................    spi_write(0x00); 
0279:  BCF    03.5
027A:  MOVF   13,W
027B:  CLRF   13
027C:  BSF    03.5
027D:  RRF    14,W
027E:  BTFSS  03.0
027F:  GOTO   27D
....................    output_high(CSN); 
0280:  BCF    03.5
0281:  BCF    45.1
0282:  MOVF   45,W
0283:  BSF    03.5
0284:  MOVWF  07
0285:  BCF    03.5
0286:  BSF    07.1
....................  
....................    //RF_CH - define o canal do modulo (TX e RX devem ser iguais) 
....................    output_low(CSN); 
0287:  BCF    45.1
0288:  MOVF   45,W
0289:  BSF    03.5
028A:  MOVWF  07
028B:  BCF    03.5
028C:  BCF    07.1
....................    spi_write(0x05); 
028D:  MOVF   13,W
028E:  MOVLW  05
028F:  MOVWF  13
0290:  BSF    03.5
0291:  RRF    14,W
0292:  BTFSS  03.0
0293:  GOTO   291
....................    spi_write(CANAL); 
0294:  BCF    03.5
0295:  MOVF   13,W
0296:  MOVLW  6B
0297:  MOVWF  13
0298:  BSF    03.5
0299:  RRF    14,W
029A:  BTFSS  03.0
029B:  GOTO   299
....................    output_high(CSN); 
029C:  BCF    03.5
029D:  BCF    45.1
029E:  MOVF   45,W
029F:  BSF    03.5
02A0:  MOVWF  07
02A1:  BCF    03.5
02A2:  BSF    07.1
....................  
....................    //RF_SETUP - ativa LNA, taxa em 250K, e maxima potencia 0dbm 
....................    output_low(CSN); 
02A3:  BCF    45.1
02A4:  MOVF   45,W
02A5:  BSF    03.5
02A6:  MOVWF  07
02A7:  BCF    03.5
02A8:  BCF    07.1
....................    spi_write(0x26); 
02A9:  MOVF   13,W
02AA:  MOVLW  26
02AB:  MOVWF  13
02AC:  BSF    03.5
02AD:  RRF    14,W
02AE:  BTFSS  03.0
02AF:  GOTO   2AD
....................    spi_write(0b00100110); 
02B0:  BCF    03.5
02B1:  MOVF   13,W
02B2:  MOVLW  26
02B3:  MOVWF  13
02B4:  BSF    03.5
02B5:  RRF    14,W
02B6:  BTFSS  03.0
02B7:  GOTO   2B5
....................    output_high(CSN); 
02B8:  BCF    03.5
02B9:  BCF    45.1
02BA:  MOVF   45,W
02BB:  BSF    03.5
02BC:  MOVWF  07
02BD:  BCF    03.5
02BE:  BSF    07.1
....................  
....................    //STATUS - reseta o resgistrador STATUS 
....................    output_low(CSN); 
02BF:  BCF    45.1
02C0:  MOVF   45,W
02C1:  BSF    03.5
02C2:  MOVWF  07
02C3:  BCF    03.5
02C4:  BCF    07.1
....................    spi_write(0x27); 
02C5:  MOVF   13,W
02C6:  MOVLW  27
02C7:  MOVWF  13
02C8:  BSF    03.5
02C9:  RRF    14,W
02CA:  BTFSS  03.0
02CB:  GOTO   2C9
....................    spi_write(0x70); 
02CC:  BCF    03.5
02CD:  MOVF   13,W
02CE:  MOVLW  70
02CF:  MOVWF  13
02D0:  BSF    03.5
02D1:  RRF    14,W
02D2:  BTFSS  03.0
02D3:  GOTO   2D1
....................    output_high(CSN); 
02D4:  BCF    03.5
02D5:  BCF    45.1
02D6:  MOVF   45,W
02D7:  BSF    03.5
02D8:  MOVWF  07
02D9:  BCF    03.5
02DA:  BSF    07.1
....................  
....................    //RX_PW_P0 - tamanho do buffer PIPE0 
....................    output_low(CSN); 
02DB:  BCF    45.1
02DC:  MOVF   45,W
02DD:  BSF    03.5
02DE:  MOVWF  07
02DF:  BCF    03.5
02E0:  BCF    07.1
....................    spi_write(0x31); 
02E1:  MOVF   13,W
02E2:  MOVLW  31
02E3:  MOVWF  13
02E4:  BSF    03.5
02E5:  RRF    14,W
02E6:  BTFSS  03.0
02E7:  GOTO   2E5
....................    spi_write(BUFFER); 
02E8:  BCF    03.5
02E9:  MOVF   13,W
02EA:  MOVLW  0A
02EB:  MOVWF  13
02EC:  BSF    03.5
02ED:  RRF    14,W
02EE:  BTFSS  03.0
02EF:  GOTO   2ED
....................    output_high(CSN); 
02F0:  BCF    03.5
02F1:  BCF    45.1
02F2:  MOVF   45,W
02F3:  BSF    03.5
02F4:  MOVWF  07
02F5:  BCF    03.5
02F6:  BSF    07.1
....................  
....................    //CONFIG - coloca em modo de recepção, e define CRC de 2 Bytes 
....................    output_low(CSN); 
02F7:  BCF    45.1
02F8:  MOVF   45,W
02F9:  BSF    03.5
02FA:  MOVWF  07
02FB:  BCF    03.5
02FC:  BCF    07.1
....................    spi_write(0x20); 
02FD:  MOVF   13,W
02FE:  MOVLW  20
02FF:  MOVWF  13
0300:  BSF    03.5
0301:  RRF    14,W
0302:  BTFSS  03.0
0303:  GOTO   301
....................    spi_write(0x0F); 
0304:  BCF    03.5
0305:  MOVF   13,W
0306:  MOVLW  0F
0307:  MOVWF  13
0308:  BSF    03.5
0309:  RRF    14,W
030A:  BTFSS  03.0
030B:  GOTO   309
....................    output_high(CSN); 
030C:  BCF    03.5
030D:  BCF    45.1
030E:  MOVF   45,W
030F:  BSF    03.5
0310:  MOVWF  07
0311:  BCF    03.5
0312:  BSF    07.1
....................     
....................    //tempo para sair do modo standby entrar em modo de recepçao 
....................    delay_ms(2); 
0313:  MOVLW  02
0314:  MOVWF  57
0315:  CALL   0B1
....................    output_high(CE); 
0316:  BCF    45.2
0317:  MOVF   45,W
0318:  BSF    03.5
0319:  MOVWF  07
031A:  BCF    03.5
031B:  BSF    07.2
....................    delay_us(150); 
031C:  MOVLW  31
031D:  MOVWF  20
031E:  DECFSZ 20,F
031F:  GOTO   31E
0320:  GOTO   321
....................     
....................    //configura interrupção no pino RB0 
....................    disable_interrupts(global); 
0321:  BCF    0B.6
0322:  BCF    0B.7
0323:  BTFSC  0B.7
0324:  GOTO   322
....................    enable_interrupts(int_ext); 
0325:  BSF    0B.4
....................    ext_int_edge( H_TO_L ); 
0326:  BSF    03.5
0327:  BCF    01.6
....................    bit_set(IRQ_TR); 
0328:  BSF    06.0
....................    enable_interrupts(global); 
0329:  MOVLW  C0
032A:  BCF    03.5
032B:  IORWF  0B,F
.................... } 
032C:  BCF    0A.3
032D:  GOTO   54E (RETURN)
....................  
.................... //função que transmite os dados 
.................... int1 envia_dados(){ 
....................     
....................    int8 i; 
....................    int8 status; 
....................  
....................    output_low(CE); 
*
03CE:  BCF    45.2
03CF:  MOVF   45,W
03D0:  BSF    03.5
03D1:  MOVWF  07
03D2:  BCF    03.5
03D3:  BCF    07.2
....................  
....................    //STATUS - reseta registrador STATUS 
....................    output_low(CSN); 
03D4:  BCF    45.1
03D5:  MOVF   45,W
03D6:  BSF    03.5
03D7:  MOVWF  07
03D8:  BCF    03.5
03D9:  BCF    07.1
....................    spi_write(0x27); 
03DA:  MOVF   13,W
03DB:  MOVLW  27
03DC:  MOVWF  13
03DD:  BSF    03.5
03DE:  RRF    14,W
03DF:  BTFSS  03.0
03E0:  GOTO   3DE
....................    spi_write(0x70); 
03E1:  BCF    03.5
03E2:  MOVF   13,W
03E3:  MOVLW  70
03E4:  MOVWF  13
03E5:  BSF    03.5
03E6:  RRF    14,W
03E7:  BTFSS  03.0
03E8:  GOTO   3E6
....................    output_high(CSN); 
03E9:  BCF    03.5
03EA:  BCF    45.1
03EB:  MOVF   45,W
03EC:  BSF    03.5
03ED:  MOVWF  07
03EE:  BCF    03.5
03EF:  BSF    07.1
....................  
....................    // W_TX_PAYLOAD - envia os dados para o buffer FIFO TX  
....................    output_low(CSN); 
03F0:  BCF    45.1
03F1:  MOVF   45,W
03F2:  BSF    03.5
03F3:  MOVWF  07
03F4:  BCF    03.5
03F5:  BCF    07.1
....................    spi_write(0xA0); 
03F6:  MOVF   13,W
03F7:  MOVLW  A0
03F8:  MOVWF  13
03F9:  BSF    03.5
03FA:  RRF    14,W
03FB:  BTFSS  03.0
03FC:  GOTO   3FA
....................    for (i=0;i<BUFFER;i++)spi_write(ENVIA[i]); 
03FD:  BCF    03.5
03FE:  CLRF   54
03FF:  MOVF   54,W
0400:  SUBLW  09
0401:  BTFSS  03.0
0402:  GOTO   411
0403:  MOVLW  3B
0404:  ADDWF  54,W
0405:  MOVWF  04
0406:  MOVF   00,W
0407:  MOVWF  56
0408:  MOVF   56,W
0409:  MOVWF  13
040A:  BSF    03.5
040B:  RRF    14,W
040C:  BTFSS  03.0
040D:  GOTO   40B
040E:  BCF    03.5
040F:  INCF   54,F
0410:  GOTO   3FF
....................    output_high(CSN); 
0411:  BCF    45.1
0412:  MOVF   45,W
0413:  BSF    03.5
0414:  MOVWF  07
0415:  BCF    03.5
0416:  BSF    07.1
....................  
....................    //CONFIG - ativa modo de transmissão 
....................    output_low(CSN); 
0417:  BCF    45.1
0418:  MOVF   45,W
0419:  BSF    03.5
041A:  MOVWF  07
041B:  BCF    03.5
041C:  BCF    07.1
....................    spi_write(0x20); 
041D:  MOVF   13,W
041E:  MOVLW  20
041F:  MOVWF  13
0420:  BSF    03.5
0421:  RRF    14,W
0422:  BTFSS  03.0
0423:  GOTO   421
....................    spi_write(0x0E); 
0424:  BCF    03.5
0425:  MOVF   13,W
0426:  MOVLW  0E
0427:  MOVWF  13
0428:  BSF    03.5
0429:  RRF    14,W
042A:  BTFSS  03.0
042B:  GOTO   429
....................    output_high(CSN); 
042C:  BCF    03.5
042D:  BCF    45.1
042E:  MOVF   45,W
042F:  BSF    03.5
0430:  MOVWF  07
0431:  BCF    03.5
0432:  BSF    07.1
....................  
....................    //pulso para transmitir os dados 
....................    output_high(CE); 
0433:  BCF    45.2
0434:  MOVF   45,W
0435:  BSF    03.5
0436:  MOVWF  07
0437:  BCF    03.5
0438:  BSF    07.2
....................    delay_us(15); 
0439:  MOVLW  04
043A:  MOVWF  20
043B:  DECFSZ 20,F
043C:  GOTO   43B
043D:  GOTO   43E
....................    output_low(CE); 
043E:  BCF    45.2
043F:  MOVF   45,W
0440:  BSF    03.5
0441:  MOVWF  07
0442:  BCF    03.5
0443:  BCF    07.2
....................  
....................    espera_ack=0; 
0444:  CLRF   2F
0445:  CLRF   2E
....................  
....................    while(input(IRQ)==1){ 
0446:  BSF    03.5
0447:  BSF    06.0
0448:  BCF    03.5
0449:  BTFSS  06.0
044A:  GOTO   456
....................       espera_ack++; 
044B:  INCF   2E,F
044C:  BTFSC  03.2
044D:  INCF   2F,F
....................       //espera 5ms, pela recepçao do pacote ACK 
....................       if(espera_ack==400){ 
044E:  MOVF   2E,W
044F:  SUBLW  90
0450:  BTFSS  03.2
0451:  GOTO   455
0452:  DECFSZ 2F,W
0453:  GOTO   455
....................       break; 
0454:  GOTO   456
....................       } 
....................    } 
0455:  GOTO   446
....................  
....................    //STATUS - leitura do registrador 
....................    output_low(CSN); 
0456:  BCF    45.1
0457:  MOVF   45,W
0458:  BSF    03.5
0459:  MOVWF  07
045A:  BCF    03.5
045B:  BCF    07.1
....................    spi_write(0x07); 
045C:  MOVF   13,W
045D:  MOVLW  07
045E:  MOVWF  13
045F:  BSF    03.5
0460:  RRF    14,W
0461:  BTFSS  03.0
0462:  GOTO   460
....................    status=spi_read(0); 
0463:  BCF    03.5
0464:  MOVF   13,W
0465:  CLRF   13
0466:  BSF    03.5
0467:  RRF    14,W
0468:  BTFSS  03.0
0469:  GOTO   467
046A:  BCF    03.5
046B:  MOVF   13,W
046C:  MOVWF  55
....................    output_high(CSN); 
046D:  BCF    45.1
046E:  MOVF   45,W
046F:  BSF    03.5
0470:  MOVWF  07
0471:  BCF    03.5
0472:  BSF    07.1
....................     
....................    //STATUS - limpa registrador 
....................    output_low(CSN); 
0473:  BCF    45.1
0474:  MOVF   45,W
0475:  BSF    03.5
0476:  MOVWF  07
0477:  BCF    03.5
0478:  BCF    07.1
....................    spi_write(0x27); 
0479:  MOVF   13,W
047A:  MOVLW  27
047B:  MOVWF  13
047C:  BSF    03.5
047D:  RRF    14,W
047E:  BTFSS  03.0
047F:  GOTO   47D
....................    spi_write(0x70); 
0480:  BCF    03.5
0481:  MOVF   13,W
0482:  MOVLW  70
0483:  MOVWF  13
0484:  BSF    03.5
0485:  RRF    14,W
0486:  BTFSS  03.0
0487:  GOTO   485
....................    output_high(CSN); 
0488:  BCF    03.5
0489:  BCF    45.1
048A:  MOVF   45,W
048B:  BSF    03.5
048C:  MOVWF  07
048D:  BCF    03.5
048E:  BSF    07.1
....................  
....................    //TX_FLUSH - limpa o buffer FIFO TX 
....................    output_low(CSN); 
048F:  BCF    45.1
0490:  MOVF   45,W
0491:  BSF    03.5
0492:  MOVWF  07
0493:  BCF    03.5
0494:  BCF    07.1
....................    spi_write(0xE1); 
0495:  MOVF   13,W
0496:  MOVLW  E1
0497:  MOVWF  13
0498:  BSF    03.5
0499:  RRF    14,W
049A:  BTFSS  03.0
049B:  GOTO   499
....................    output_high(CSN); 
049C:  BCF    03.5
049D:  BCF    45.1
049E:  MOVF   45,W
049F:  BSF    03.5
04A0:  MOVWF  07
04A1:  BCF    03.5
04A2:  BSF    07.1
....................  
....................    //CONFIG - configura para modo de recepção 
....................    output_low(CSN); 
04A3:  BCF    45.1
04A4:  MOVF   45,W
04A5:  BSF    03.5
04A6:  MOVWF  07
04A7:  BCF    03.5
04A8:  BCF    07.1
....................    spi_write(0x20); 
04A9:  MOVF   13,W
04AA:  MOVLW  20
04AB:  MOVWF  13
04AC:  BSF    03.5
04AD:  RRF    14,W
04AE:  BTFSS  03.0
04AF:  GOTO   4AD
....................    spi_write(0x0F); 
04B0:  BCF    03.5
04B1:  MOVF   13,W
04B2:  MOVLW  0F
04B3:  MOVWF  13
04B4:  BSF    03.5
04B5:  RRF    14,W
04B6:  BTFSS  03.0
04B7:  GOTO   4B5
....................    output_high(CSN); 
04B8:  BCF    03.5
04B9:  BCF    45.1
04BA:  MOVF   45,W
04BB:  BSF    03.5
04BC:  MOVWF  07
04BD:  BCF    03.5
04BE:  BSF    07.1
....................  
....................    output_high(CE); 
04BF:  BCF    45.2
04C0:  MOVF   45,W
04C1:  BSF    03.5
04C2:  MOVWF  07
04C3:  BCF    03.5
04C4:  BSF    07.2
....................  
....................    delay_us(150); 
04C5:  MOVLW  31
04C6:  MOVWF  20
04C7:  DECFSZ 20,F
04C8:  GOTO   4C7
04C9:  GOTO   4CA
....................  
....................    //senão recebeu ACK em 5ms retorna 0 
....................    if(espera_ack==500){ 
04CA:  MOVF   2E,W
04CB:  SUBLW  F4
04CC:  BTFSS  03.2
04CD:  GOTO   4D7
04CE:  DECFSZ 2F,W
04CF:  GOTO   4D7
....................    clear_interrupt(int_ext); 
04D0:  BCF    0B.1
....................    enable_interrupts(GLOBAL); 
04D1:  MOVLW  C0
04D2:  IORWF  0B,F
....................    return(0); 
04D3:  MOVLW  00
04D4:  MOVWF  21
04D5:  GOTO   4DD
....................    } 
....................    //se recebeu ACK retorna 1 
....................    else{ 
04D6:  GOTO   4DD
....................    enable_interrupts(GLOBAL); 
04D7:  MOVLW  C0
04D8:  IORWF  0B,F
....................    clear_interrupt(int_ext); 
04D9:  BCF    0B.1
....................    return(1); 
04DA:  MOVLW  01
04DB:  MOVWF  21
04DC:  GOTO   4DD
....................    } 
.................... } 
04DD:  BCF    0A.3
04DE:  GOTO   63A (RETURN)
....................  
.................... //função que recebe os dados e joga num vetor 
.................... int1 recebe_dados(){ 
....................  
....................    int8 i; 
....................    int8 status; 
....................     
....................    //desabilita interrupção 
....................    disable_interrupts(GLOBAL); 
*
003D:  BCF    0B.6
003E:  BCF    0B.7
003F:  BTFSC  0B.7
0040:  GOTO   03E
....................     
....................    //STATUS - leitura do registrador 
....................    output_low(CSN); 
0041:  BCF    45.1
0042:  MOVF   45,W
0043:  BSF    03.5
0044:  MOVWF  07
0045:  BCF    03.5
0046:  BCF    07.1
....................    spi_write(0x07); 
0047:  MOVF   13,W
0048:  MOVLW  07
0049:  MOVWF  13
004A:  BSF    03.5
004B:  RRF    14,W
004C:  BTFSS  03.0
004D:  GOTO   04B
....................    status=spi_read(0); 
004E:  BCF    03.5
004F:  MOVF   13,W
0050:  CLRF   13
0051:  BSF    03.5
0052:  RRF    14,W
0053:  BTFSS  03.0
0054:  GOTO   052
0055:  BCF    03.5
0056:  MOVF   13,W
0057:  MOVWF  61
....................    output_high(CSN); 
0058:  BCF    45.1
0059:  MOVF   45,W
005A:  BSF    03.5
005B:  MOVWF  07
005C:  BCF    03.5
005D:  BSF    07.1
....................     
....................    //STATUS - limpa registrador 
....................    output_low(CSN); 
005E:  BCF    45.1
005F:  MOVF   45,W
0060:  BSF    03.5
0061:  MOVWF  07
0062:  BCF    03.5
0063:  BCF    07.1
....................    spi_write(0x27); 
0064:  MOVF   13,W
0065:  MOVLW  27
0066:  MOVWF  13
0067:  BSF    03.5
0068:  RRF    14,W
0069:  BTFSS  03.0
006A:  GOTO   068
....................    spi_write(0x70); 
006B:  BCF    03.5
006C:  MOVF   13,W
006D:  MOVLW  70
006E:  MOVWF  13
006F:  BSF    03.5
0070:  RRF    14,W
0071:  BTFSS  03.0
0072:  GOTO   070
....................    output_high(CSN); 
0073:  BCF    03.5
0074:  BCF    45.1
0075:  MOVF   45,W
0076:  BSF    03.5
0077:  MOVWF  07
0078:  BCF    03.5
0079:  BSF    07.1
....................     
....................    //verifica o bit de recepção de dados 
....................    if(bit_test(status,6)==0){ 
007A:  BTFSC  61.6
007B:  GOTO   07F
....................    return(0); 
007C:  MOVLW  00
007D:  MOVWF  21
007E:  GOTO   0AB
....................    } 
....................     
....................    //R_RX_PAYLOAD - recebe os dados do buffer FIFO RX 
....................    output_low(CSN); 
007F:  BCF    45.1
0080:  MOVF   45,W
0081:  BSF    03.5
0082:  MOVWF  07
0083:  BCF    03.5
0084:  BCF    07.1
....................    spi_write(0x61); 
0085:  MOVF   13,W
0086:  MOVLW  61
0087:  MOVWF  13
0088:  BSF    03.5
0089:  RRF    14,W
008A:  BTFSS  03.0
008B:  GOTO   089
....................    for(i=0;i<BUFFER;i++)RECEBE[i]=spi_read(0); 
008C:  BCF    03.5
008D:  CLRF   60
008E:  MOVF   60,W
008F:  SUBLW  09
0090:  BTFSS  03.0
0091:  GOTO   0A0
0092:  MOVLW  31
0093:  ADDWF  60,W
0094:  MOVWF  04
0095:  MOVF   13,W
0096:  CLRF   13
0097:  BSF    03.5
0098:  RRF    14,W
0099:  BTFSS  03.0
009A:  GOTO   098
009B:  BCF    03.5
009C:  MOVF   13,W
009D:  MOVWF  00
009E:  INCF   60,F
009F:  GOTO   08E
....................    output_high(CSN); 
00A0:  BCF    45.1
00A1:  MOVF   45,W
00A2:  BSF    03.5
00A3:  MOVWF  07
00A4:  BCF    03.5
00A5:  BSF    07.1
....................     
....................    //habilita interrupção 
....................    clear_interrupt(int_ext); 
00A6:  BCF    0B.1
....................    enable_interrupts(GLOBAL); 
00A7:  MOVLW  C0
00A8:  IORWF  0B,F
....................     
....................    return(1); 
00A9:  MOVLW  01
00AA:  MOVWF  21
.................... } 
....................  
.................... //Interrupção pino RB0 
.................... #int_ext  
.................... void interrupcao(){  
....................     
....................    //função recebe dados 
....................    ACK=recebe_dados(); 
00AB:  BCF    30.0
00AC:  BTFSC  21.0
00AD:  BSF    30.0
.................... }  
....................  
.................... #include <flex_lcd.c> 
.................... // flex_lcd.c 
....................  
.................... // These pins are for the Microchip PicDem2-Plus board, 
.................... // which is what I used to test the driver.  Change these 
.................... // pins to fit your own board. 
....................  
.................... #define LCD_DB4   PIN_B4 
.................... #define LCD_DB5   PIN_B5 
.................... #define LCD_DB6   PIN_B6 
.................... #define LCD_DB7   PIN_B7 
....................  
.................... #define LCD_E     PIN_B1 
.................... #define LCD_RS    PIN_B2 
.................... #define LCD_RW    PIN_B3 
....................  
.................... /* 
.................... #define LCD_DB4   PIN_B4 
.................... #define LCD_DB5   PIN_B5 
.................... #define LCD_DB6   PIN_B6 
.................... #define LCD_DB7   PIN_B7 
....................  
.................... #define LCD_E     PIN_B0 
.................... #define LCD_RS    PIN_A6 
.................... #define LCD_RW    PIN_A7 
.................... */ 
....................  
.................... // If you only want a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line. 
....................  
.................... #define USE_LCD_RW   1 
....................  
.................... //======================================== 
....................  
.................... #define lcd_type 2        // 0=5×7, 1=5×10, 2=2 lines 
.................... #define lcd_line_two 0x40 // LCD RAM address for the 2nd line 
....................  
00AE:  BCF    0B.1
00AF:  BCF    0A.3
00B0:  GOTO   020
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
.................... //0 
.................... 20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5×8 dots 
.................... 0xc,                    // Display on 
.................... 1,                      // Clear display 
.................... 6                       // Increment cursor 
.................... }; 
....................  
.................... //————————————- 
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
.................... // Note:  !! converts an integer expression 
.................... // to a boolean (1 or 0). 
.................... output_bit(LCD_DB4, !!(nibble & 1)); 
*
00C5:  BTFSC  5E.0
00C6:  GOTO   0C9
00C7:  BCF    06.4
00C8:  GOTO   0CA
00C9:  BSF    06.4
00CA:  BSF    03.5
00CB:  BCF    06.4
.................... output_bit(LCD_DB5, !!(nibble & 2)); 
00CC:  BCF    03.5
00CD:  BTFSC  5E.1
00CE:  GOTO   0D1
00CF:  BCF    06.5
00D0:  GOTO   0D2
00D1:  BSF    06.5
00D2:  BSF    03.5
00D3:  BCF    06.5
.................... output_bit(LCD_DB6, !!(nibble & 4)); 
00D4:  BCF    03.5
00D5:  BTFSC  5E.2
00D6:  GOTO   0D9
00D7:  BCF    06.6
00D8:  GOTO   0DA
00D9:  BSF    06.6
00DA:  BSF    03.5
00DB:  BCF    06.6
.................... output_bit(LCD_DB7, !!(nibble & 8)); 
00DC:  BCF    03.5
00DD:  BTFSC  5E.3
00DE:  GOTO   0E1
00DF:  BCF    06.7
00E0:  GOTO   0E2
00E1:  BSF    06.7
00E2:  BSF    03.5
00E3:  BCF    06.7
....................  
.................... delay_cycles(1); 
00E4:  NOP
.................... output_high(LCD_E); 
00E5:  BCF    06.1
00E6:  BCF    03.5
00E7:  BSF    06.1
.................... delay_us(2); 
00E8:  GOTO   0E9
.................... output_low(LCD_E); 
00E9:  BSF    03.5
00EA:  BCF    06.1
00EB:  BCF    03.5
00EC:  BCF    06.1
.................... } 
00ED:  RETLW  00
....................  
.................... //———————————– 
.................... // This sub-routine is only called by lcd_read_byte(). 
.................... // It’s not a stand-alone routine.  For example, the 
.................... // R/W signal is set high by lcd_read_byte() before 
.................... // this routine is called. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_nibble(void) 
.................... { 
.................... int8 retval; 
.................... // Create bit variables so that we can easily set 
.................... // individual bits in the retval variable. 
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
....................  
.................... retval = 0; 
00EE:  CLRF   5F
....................  
.................... output_high(LCD_E); 
00EF:  BSF    03.5
00F0:  BCF    06.1
00F1:  BCF    03.5
00F2:  BSF    06.1
.................... delay_cycles(1); 
00F3:  NOP
....................  
.................... retval_0 = input(LCD_DB4); 
00F4:  BSF    03.5
00F5:  BSF    06.4
00F6:  BCF    03.5
00F7:  BCF    5F.0
00F8:  BTFSC  06.4
00F9:  BSF    5F.0
.................... retval_1 = input(LCD_DB5); 
00FA:  BSF    03.5
00FB:  BSF    06.5
00FC:  BCF    03.5
00FD:  BCF    5F.1
00FE:  BTFSC  06.5
00FF:  BSF    5F.1
.................... retval_2 = input(LCD_DB6); 
0100:  BSF    03.5
0101:  BSF    06.6
0102:  BCF    03.5
0103:  BCF    5F.2
0104:  BTFSC  06.6
0105:  BSF    5F.2
.................... retval_3 = input(LCD_DB7); 
0106:  BSF    03.5
0107:  BSF    06.7
0108:  BCF    03.5
0109:  BCF    5F.3
010A:  BTFSC  06.7
010B:  BSF    5F.3
....................  
.................... output_low(LCD_E); 
010C:  BSF    03.5
010D:  BCF    06.1
010E:  BCF    03.5
010F:  BCF    06.1
....................  
.................... return(retval); 
0110:  MOVF   5F,W
0111:  MOVWF  21
.................... } 
0112:  RETLW  00
.................... #endif 
....................  
.................... //————————————— 
.................... // Read a byte from the LCD and return it. 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_byte(void) 
.................... { 
.................... int8 low; 
.................... int8 high; 
....................  
.................... output_high(LCD_RW); 
*
0117:  BSF    03.5
0118:  BCF    06.3
0119:  BCF    03.5
011A:  BSF    06.3
.................... delay_cycles(1); 
011B:  NOP
....................  
.................... high = lcd_read_nibble(); 
011C:  CALL   0EE
011D:  MOVF   21,W
011E:  MOVWF  5E
....................  
.................... low = lcd_read_nibble(); 
011F:  CALL   0EE
0120:  MOVF   21,W
0121:  MOVWF  5D
....................  
.................... return( (high<<4) | low); 
0122:  SWAPF  5E,W
0123:  MOVWF  20
0124:  MOVLW  F0
0125:  ANDWF  20,F
0126:  MOVF   20,W
0127:  IORWF  5D,W
0128:  MOVWF  21
.................... } 
.................... #endif 
....................  
.................... //—————————————- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... output_low(LCD_RS); 
*
0113:  BSF    03.5
0114:  BCF    06.2
0115:  BCF    03.5
0116:  BCF    06.2
....................  
.................... #ifdef USE_LCD_RW 
.................... while(bit_test(lcd_read_byte(),7)) ; 
*
0129:  MOVF   21,W
012A:  MOVWF  5D
012B:  BTFSC  5D.7
012C:  GOTO   117
.................... #else 
.................... delay_us(60); 
.................... #endif 
....................  
.................... if(address) 
012D:  MOVF   5B,F
012E:  BTFSC  03.2
012F:  GOTO   135
.................... output_high(LCD_RS); 
0130:  BSF    03.5
0131:  BCF    06.2
0132:  BCF    03.5
0133:  BSF    06.2
.................... else 
0134:  GOTO   139
.................... output_low(LCD_RS); 
0135:  BSF    03.5
0136:  BCF    06.2
0137:  BCF    03.5
0138:  BCF    06.2
....................  
.................... delay_cycles(1); 
0139:  NOP
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
013A:  BSF    03.5
013B:  BCF    06.3
013C:  BCF    03.5
013D:  BCF    06.3
.................... delay_cycles(1); 
013E:  NOP
.................... #endif 
....................  
.................... output_low(LCD_E); 
013F:  BSF    03.5
0140:  BCF    06.1
0141:  BCF    03.5
0142:  BCF    06.1
....................  
.................... lcd_send_nibble(n >> 4); 
0143:  SWAPF  5C,W
0144:  MOVWF  5D
0145:  MOVLW  0F
0146:  ANDWF  5D,F
0147:  MOVF   5D,W
0148:  MOVWF  5E
0149:  CALL   0C5
.................... lcd_send_nibble(n & 0xf); 
014A:  MOVF   5C,W
014B:  ANDLW  0F
014C:  MOVWF  5D
014D:  MOVWF  5E
014E:  CALL   0C5
.................... } 
014F:  RETLW  00
....................  
.................... //—————————- 
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... output_low(LCD_RS); 
0150:  BSF    03.5
0151:  BCF    06.2
0152:  BCF    03.5
0153:  BCF    06.2
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
0154:  BSF    03.5
0155:  BCF    06.3
0156:  BCF    03.5
0157:  BCF    06.3
.................... #endif 
....................  
.................... output_low(LCD_E); 
0158:  BSF    03.5
0159:  BCF    06.1
015A:  BCF    03.5
015B:  BCF    06.1
....................  
.................... delay_ms(15); 
015C:  MOVLW  0F
015D:  MOVWF  57
015E:  CALL   0B1
....................  
.................... for(i=0 ;i < 3; i++) 
015F:  CLRF   54
0160:  MOVF   54,W
0161:  SUBLW  02
0162:  BTFSS  03.0
0163:  GOTO   16C
.................... { 
.................... lcd_send_nibble(0x03); 
0164:  MOVLW  03
0165:  MOVWF  5E
0166:  CALL   0C5
.................... delay_ms(5); 
0167:  MOVLW  05
0168:  MOVWF  57
0169:  CALL   0B1
.................... } 
016A:  INCF   54,F
016B:  GOTO   160
....................  
.................... lcd_send_nibble(0x02); 
016C:  MOVLW  02
016D:  MOVWF  5E
016E:  CALL   0C5
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
016F:  CLRF   54
0170:  MOVF   54,W
0171:  SUBLW  03
0172:  BTFSS  03.0
0173:  GOTO   17D
.................... { 
.................... lcd_send_byte(0, LCD_INIT_STRING[i]); 
0174:  MOVF   54,W
0175:  CALL   035
0176:  MOVWF  55
0177:  CLRF   5B
0178:  MOVF   55,W
0179:  MOVWF  5C
017A:  CALL   113
....................  
.................... // If the R/W signal is not used, then 
.................... // the busy bit can’t be polled.  One of 
.................... // the init commands takes longer than 
.................... // the hard-coded delay of 60 us, so in 
.................... // that case, lets just do a 5 ms delay 
.................... // after all four of them. 
.................... #ifndef USE_LCD_RW 
.................... delay_ms(5); 
.................... #endif 
.................... } 
017B:  INCF   54,F
017C:  GOTO   170
....................  
.................... } 
017D:  BCF    0A.3
017E:  GOTO   54D (RETURN)
....................  
.................... //—————————- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
.................... if(y != 1) 
*
0345:  DECFSZ 58,W
0346:  GOTO   348
0347:  GOTO   34B
.................... address = lcd_line_two; 
0348:  MOVLW  40
0349:  MOVWF  59
.................... else 
034A:  GOTO   34C
.................... address=0; 
034B:  CLRF   59
....................  
.................... address += x-1; 
034C:  MOVLW  01
034D:  SUBWF  57,W
034E:  ADDWF  59,F
.................... lcd_send_byte(0, 0x80 | address); 
034F:  MOVF   59,W
0350:  IORLW  80
0351:  MOVWF  5A
0352:  CLRF   5B
0353:  MOVF   5A,W
0354:  MOVWF  5C
0355:  CALL   113
.................... } 
....................  
.................... //—————————– 
.................... void lcd_putc(char c) 
.................... { 
.................... switch(c) 
.................... { 
*
032E:  MOVF   56,W
032F:  XORLW  0C
0330:  BTFSC  03.2
0331:  GOTO   339
0332:  XORLW  06
0333:  BTFSC  03.2
0334:  GOTO   341
0335:  XORLW  02
0336:  BTFSC  03.2
0337:  GOTO   357
0338:  GOTO   35C
.................... case '\f': 
.................... lcd_send_byte(0,1); 
0339:  CLRF   5B
033A:  MOVLW  01
033B:  MOVWF  5C
033C:  CALL   113
.................... delay_ms(2); 
033D:  MOVLW  02
033E:  MOVWF  57
033F:  CALL   0B1
.................... break; 
0340:  GOTO   362
....................  
.................... case '\n': 
.................... lcd_gotoxy(1,2); 
0341:  MOVLW  01
0342:  MOVWF  57
0343:  MOVLW  02
0344:  MOVWF  58
.................... break; 
*
0356:  GOTO   362
....................  
.................... case '\b': 
.................... lcd_send_byte(0,0x10); 
0357:  CLRF   5B
0358:  MOVLW  10
0359:  MOVWF  5C
035A:  CALL   113
.................... break; 
035B:  GOTO   362
....................  
.................... default: 
.................... lcd_send_byte(1,c); 
035C:  MOVLW  01
035D:  MOVWF  5B
035E:  MOVF   56,W
035F:  MOVWF  5C
0360:  CALL   113
.................... break; 
0361:  GOTO   362
.................... } 
.................... } 
0362:  RETLW  00
....................  
.................... //—————————— 
.................... #ifdef USE_LCD_RW 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
....................  
.................... lcd_gotoxy(x,y); 
....................  
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7)); 
....................  
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(lcd_RS); 
....................  
.................... return(value); 
.................... } 
.................... #endif 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //PINO ENTRE O PIC E O MODULO NRF24L01+ 
.................... //PIC: RB0 > MODULO: IRQ 
.................... //PIC: RC1 > MODULO: CSN 
.................... //PIC: RC2 > MODULO: CE 
.................... //PIC: RC3 > MODULO: SCK 
.................... //PIC: RC5 > MODULO: MISO 
.................... //PIC: RC4 > MODULO: MOSI 
.................... //------------------------------------------------------------------------------ 
.................... //PINOS DO LCD 16X2 
.................... //PIC: RB1 > MODULO: ENABLE 
.................... //PIC: RB2 > MODULO: RS 
.................... //PIC: RB3 > MODULO: RW 
.................... //PIC: RB4 > MODULO: D4 
.................... //PIC: RB5 > MODULO: D5 
.................... //PIC: RB6 > MODULO: D6 
.................... //PIC: RB7 > MODULO: D7 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //variaveis 
.................... int8 a,b,c,d;  
.................... int8 teste[10]={1,2,3,4,5,6,7,8}; 
*
0503:  MOVLW  01
0504:  MOVWF  4A
0505:  MOVLW  02
0506:  MOVWF  4B
0507:  MOVLW  03
0508:  MOVWF  4C
0509:  MOVLW  04
050A:  MOVWF  4D
050B:  MOVLW  05
050C:  MOVWF  4E
050D:  MOVLW  06
050E:  MOVWF  4F
050F:  MOVLW  07
0510:  MOVWF  50
0511:  MOVLW  08
0512:  MOVWF  51
0513:  CLRF   52
0514:  CLRF   53
....................  
.................... //programa principal 
.................... void main(){  
*
04DF:  CLRF   04
04E0:  MOVLW  1F
04E1:  ANDWF  03,F
04E2:  BSF    03.5
04E3:  BSF    1F.0
04E4:  BSF    1F.1
04E5:  BSF    1F.2
04E6:  BCF    1F.3
04E7:  MOVLW  07
04E8:  MOVWF  1C
....................  
....................    setup_adc_ports(NO_ANALOGS); 
*
0515:  BSF    03.5
0516:  BSF    1F.0
0517:  BSF    1F.1
0518:  BSF    1F.2
0519:  BCF    1F.3
....................    setup_adc(ADC_OFF); 
051A:  BCF    03.5
051B:  BCF    1F.0
....................    setup_spi(SPI_SS_DISABLED); 
051C:  BCF    14.5
051D:  BCF    45.5
051E:  MOVF   45,W
051F:  BSF    03.5
0520:  MOVWF  07
0521:  BCF    03.5
0522:  BSF    45.4
0523:  MOVF   45,W
0524:  BSF    03.5
0525:  MOVWF  07
0526:  BCF    03.5
0527:  BCF    45.3
0528:  MOVF   45,W
0529:  BSF    03.5
052A:  MOVWF  07
052B:  MOVLW  01
052C:  BCF    03.5
052D:  MOVWF  14
052E:  MOVLW  00
052F:  BSF    03.5
0530:  MOVWF  14
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
0531:  MOVF   01,W
0532:  ANDLW  C7
0533:  IORLW  08
0534:  MOVWF  01
....................    setup_timer_1(T1_DISABLED); 
0535:  BCF    03.5
0536:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0537:  MOVLW  00
0538:  MOVWF  21
0539:  MOVWF  12
053A:  MOVLW  00
053B:  BSF    03.5
053C:  MOVWF  12
....................    setup_comparator(NC_NC_NC_NC); 
053D:  MOVLW  07
053E:  MOVWF  1C
053F:  MOVF   05,W
0540:  MOVLW  03
0541:  BCF    03.5
0542:  MOVWF  20
0543:  DECFSZ 20,F
0544:  GOTO   543
0545:  BSF    03.5
0546:  MOVF   1C,W
0547:  BCF    03.5
0548:  BCF    0D.6
....................    setup_vref(FALSE); 
0549:  BSF    03.5
054A:  CLRF   1D
....................     
....................    //inicia e configura LCD 
....................    lcd_init(); 
054B:  BCF    03.5
054C:  GOTO   150
....................     
....................    //inicia e configura modulo 
....................    config_nrf24();  
054D:  GOTO   17F
....................      
....................   
....................    while(true){  
....................     
....................       output_high(pin_C0); 
054E:  BCF    45.0
054F:  MOVF   45,W
0550:  BSF    03.5
0551:  MOVWF  07
0552:  BCF    03.5
0553:  BSF    07.0
....................       Delay_ms(500); 
0554:  MOVLW  02
0555:  MOVWF  54
0556:  MOVLW  FA
0557:  MOVWF  57
0558:  CALL   0B1
0559:  DECFSZ 54,F
055A:  GOTO   556
....................       output_low(pin_C0); 
055B:  BCF    45.0
055C:  MOVF   45,W
055D:  BSF    03.5
055E:  MOVWF  07
055F:  BCF    03.5
0560:  BCF    07.0
....................       Delay_ms(500); 
0561:  MOVLW  02
0562:  MOVWF  54
0563:  MOVLW  FA
0564:  MOVWF  57
0565:  CALL   0B1
0566:  DECFSZ 54,F
0567:  GOTO   563
....................        
....................       ENVIA[0]=teste[0]++;  
0568:  MOVF   4A,W
0569:  INCF   4A,F
056A:  MOVWF  3B
....................       ENVIA[1]=teste[1]++;  
056B:  MOVF   4B,W
056C:  INCF   4B,F
056D:  MOVWF  3C
....................       ENVIA[2]=teste[2]++;  
056E:  MOVF   4C,W
056F:  INCF   4C,F
0570:  MOVWF  3D
....................       ENVIA[3]=teste[3]++;  
0571:  MOVF   4D,W
0572:  INCF   4D,F
0573:  MOVWF  3E
....................       ENVIA[4]=teste[4]++;  
0574:  MOVF   4E,W
0575:  INCF   4E,F
0576:  MOVWF  3F
....................       ENVIA[5]=teste[5]++;  
0577:  MOVF   4F,W
0578:  INCF   4F,F
0579:  MOVWF  40
....................       ENVIA[6]=teste[6]++;  
057A:  MOVF   50,W
057B:  INCF   50,F
057C:  MOVWF  41
....................       ENVIA[7]=teste[7]++;  
057D:  MOVF   51,W
057E:  INCF   51,F
057F:  MOVWF  42
....................       ENVIA[8]=teste[8]++; 
0580:  MOVF   52,W
0581:  INCF   52,F
0582:  MOVWF  43
....................       ENVIA[9]=teste[9]++;  
0583:  MOVF   53,W
0584:  INCF   53,F
0585:  MOVWF  44
....................        
....................       //le status 
....................       output_low(CSN); 
0586:  BCF    45.1
0587:  MOVF   45,W
0588:  BSF    03.5
0589:  MOVWF  07
058A:  BCF    03.5
058B:  BCF    07.1
....................       spi_write(0x07); 
058C:  MOVF   13,W
058D:  MOVLW  07
058E:  MOVWF  13
058F:  BSF    03.5
0590:  RRF    14,W
0591:  BTFSS  03.0
0592:  GOTO   590
....................       a=spi_read(0); 
0593:  BCF    03.5
0594:  MOVF   13,W
0595:  CLRF   13
0596:  BSF    03.5
0597:  RRF    14,W
0598:  BTFSS  03.0
0599:  GOTO   597
059A:  BCF    03.5
059B:  MOVF   13,W
059C:  MOVWF  46
....................       output_high(CSN); 
059D:  BCF    45.1
059E:  MOVF   45,W
059F:  BSF    03.5
05A0:  MOVWF  07
05A1:  BCF    03.5
05A2:  BSF    07.1
....................        
....................       //le config 
....................       output_low(CSN); 
05A3:  BCF    45.1
05A4:  MOVF   45,W
05A5:  BSF    03.5
05A6:  MOVWF  07
05A7:  BCF    03.5
05A8:  BCF    07.1
....................       spi_write(0x00); 
05A9:  MOVF   13,W
05AA:  CLRF   13
05AB:  BSF    03.5
05AC:  RRF    14,W
05AD:  BTFSS  03.0
05AE:  GOTO   5AC
....................       b=spi_read(0); 
05AF:  BCF    03.5
05B0:  MOVF   13,W
05B1:  CLRF   13
05B2:  BSF    03.5
05B3:  RRF    14,W
05B4:  BTFSS  03.0
05B5:  GOTO   5B3
05B6:  BCF    03.5
05B7:  MOVF   13,W
05B8:  MOVWF  47
....................       output_high(CSN); 
05B9:  BCF    45.1
05BA:  MOVF   45,W
05BB:  BSF    03.5
05BC:  MOVWF  07
05BD:  BCF    03.5
05BE:  BSF    07.1
....................        
....................       // EN_RXADDR 
....................       output_low(CSN); 
05BF:  BCF    45.1
05C0:  MOVF   45,W
05C1:  BSF    03.5
05C2:  MOVWF  07
05C3:  BCF    03.5
05C4:  BCF    07.1
....................       spi_write(0x02); 
05C5:  MOVF   13,W
05C6:  MOVLW  02
05C7:  MOVWF  13
05C8:  BSF    03.5
05C9:  RRF    14,W
05CA:  BTFSS  03.0
05CB:  GOTO   5C9
....................       c=spi_read(0); 
05CC:  BCF    03.5
05CD:  MOVF   13,W
05CE:  CLRF   13
05CF:  BSF    03.5
05D0:  RRF    14,W
05D1:  BTFSS  03.0
05D2:  GOTO   5D0
05D3:  BCF    03.5
05D4:  MOVF   13,W
05D5:  MOVWF  48
....................       output_high(CSN); 
05D6:  BCF    45.1
05D7:  MOVF   45,W
05D8:  BSF    03.5
05D9:  MOVWF  07
05DA:  BCF    03.5
05DB:  BSF    07.1
....................        
....................       //RX_PW0 
....................       output_low(CSN); 
05DC:  BCF    45.1
05DD:  MOVF   45,W
05DE:  BSF    03.5
05DF:  MOVWF  07
05E0:  BCF    03.5
05E1:  BCF    07.1
....................       spi_write(0x0A); 
05E2:  MOVF   13,W
05E3:  MOVLW  0A
05E4:  MOVWF  13
05E5:  BSF    03.5
05E6:  RRF    14,W
05E7:  BTFSS  03.0
05E8:  GOTO   5E6
....................       d=spi_read(0); 
05E9:  BCF    03.5
05EA:  MOVF   13,W
05EB:  CLRF   13
05EC:  BSF    03.5
05ED:  RRF    14,W
05EE:  BTFSS  03.0
05EF:  GOTO   5ED
05F0:  BCF    03.5
05F1:  MOVF   13,W
05F2:  MOVWF  49
....................       output_high(CSN); 
05F3:  BCF    45.1
05F4:  MOVF   45,W
05F5:  BSF    03.5
05F6:  MOVWF  07
05F7:  BCF    03.5
05F8:  BSF    07.1
....................        
....................        
....................       printf(lcd_putc, "\f%u,%u,%u,%u\n%X,%X,%X,%X"  
....................       RECEBE[0],RECEBE[1],RECEBE[2],RECEBE[3],a,b,c,d); 
05F9:  MOVLW  0C
05FA:  MOVWF  56
05FB:  CALL   32E
05FC:  MOVF   31,W
05FD:  MOVWF  54
05FE:  MOVLW  1B
05FF:  MOVWF  55
0600:  CALL   378
0601:  MOVLW  2C
0602:  MOVWF  56
0603:  CALL   32E
0604:  MOVF   32,W
0605:  MOVWF  54
0606:  MOVLW  1B
0607:  MOVWF  55
0608:  CALL   378
0609:  MOVLW  2C
060A:  MOVWF  56
060B:  CALL   32E
060C:  MOVF   33,W
060D:  MOVWF  54
060E:  MOVLW  1B
060F:  MOVWF  55
0610:  CALL   378
0611:  MOVLW  2C
0612:  MOVWF  56
0613:  CALL   32E
0614:  MOVF   34,W
0615:  MOVWF  54
0616:  MOVLW  1B
0617:  MOVWF  55
0618:  CALL   378
0619:  MOVLW  0A
061A:  MOVWF  56
061B:  CALL   32E
061C:  MOVF   46,W
061D:  MOVWF  54
061E:  MOVLW  37
061F:  MOVWF  55
0620:  CALL   3AD
0621:  MOVLW  2C
0622:  MOVWF  56
0623:  CALL   32E
0624:  MOVF   47,W
0625:  MOVWF  54
0626:  MOVLW  37
0627:  MOVWF  55
0628:  CALL   3AD
0629:  MOVLW  2C
062A:  MOVWF  56
062B:  CALL   32E
062C:  MOVF   48,W
062D:  MOVWF  54
062E:  MOVLW  37
062F:  MOVWF  55
0630:  CALL   3AD
0631:  MOVLW  2C
0632:  MOVWF  56
0633:  CALL   32E
0634:  MOVF   49,W
0635:  MOVWF  54
0636:  MOVLW  37
0637:  MOVWF  55
0638:  CALL   3AD
....................        
....................       ACK=envia_dados(); 
0639:  GOTO   3CE
063A:  BCF    30.0
063B:  BTFSC  21.0
063C:  BSF    30.0
....................    } 
063D:  GOTO   54E
.................... } 
....................  
063E:  SLEEP

Configuration Fuses:
   Word  1: 3F31   XT NOWDT PUT NODEBUG NOPROTECT NOBROWNOUT NOLVP NOCPD NOWRT
